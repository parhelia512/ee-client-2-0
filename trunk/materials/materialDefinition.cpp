//-----------------------------------------------------------------------------
// Torque Shader Engine
// Copyright (C) GarageGames.com, Inc.
//-----------------------------------------------------------------------------

#include "platform/platform.h"
#include "materials/materialDefinition.h"

#include "console/consoleTypes.h"
#include "math/mathTypes.h"
#include "materials/materialManager.h"
#include "sceneData.h"
#include "gfx/sim/cubemapData.h"
#include "gfx/gfxCubemap.h"
#include "math/mathIO.h"
#include "materials/matInstance.h"
#include "sfx/sfxProfile.h"
#include "core/util/safeDelete.h"


GFXCubemap * Material::GetNormalizeCube()
{
   if(smNormalizeCube)
      return smNormalizeCube;
   smNormalizeCube = GFX->createCubemap();
   smNormalizeCube->initNormalize(64);
   return smNormalizeCube;
}


IMPLEMENT_CONOBJECT(Material);

static EnumTable::Enums gAnimFlagEnums[] =
{   
   { Material::Scroll, "Scroll" },
   { Material::Rotate, "Rotate" },
   { Material::Wave, "Wave" },
   { Material::Scale, "Scale" },
   { Material::Sequence, "Sequence" }
};
EnumTable Material::mAnimFlagTable( 5, gAnimFlagEnums );

static EnumTable::Enums gBlendOpEnums[] =
{
   { Material::None,         "None" },
   { Material::Mul,          "Mul" },
   { Material::Add,          "Add" },
   { Material::AddAlpha,     "AddAlpha" },
   { Material::Sub,          "Sub" },
   { Material::LerpAlpha,    "LerpAlpha" }
};
EnumTable Material::mBlendOpTable( 6, gBlendOpEnums );

static EnumTable::Enums gWaveTypeEnums[] =
{
   { Material::Sin,          "Sin" },
   { Material::Triangle,     "Triangle" },
   { Material::Square,       "Square" },
};
EnumTable Material::mWaveTypeTable( 3, gWaveTypeEnums );

GFXCubemapHandle Material::smNormalizeCube;

Material::Material()
{
   for( U32 i=0; i<MAX_STAGES; i++ )
   {
      mDiffuse[i].set( 1.0f, 1.0f, 1.0f, 0.0f );
      mSpecular[i].set( 1.0f, 1.0f, 1.0f, 1.0f );
      mColorMultiply[i].set(0.0f, 0.0f, 0.0f, 0.0f);

      mSpecularPower[i] = 8.0f;
      mPixelSpecular[i] = false;

      mParallaxScale[i] = 0.0f;

      mVertLit[i] = false;

      mExposure[i] = 1;

      mGlow[i] = false;
      mEmissive[i] = false;

      mDetailScale[i].set( 2.0f, 2.0f );
      
      mMinnaertConstant[i] = -1.0f;
      mSubSurface[i] = false;
      mSubSurfaceColor[i].set( 1.0f, 0.2f, 0.2f, 1.0f );
      mSubSurfaceRolloff[i] = 0.2f;
      
      mAnimFlags[i] = 0;

      mScrollDir[i].set( 0.0f, 0.0f );
      mScrollSpeed[i] = 0.0f;
      mScrollOffset[i].set( 0.0f, 0.0f );
      
      mRotSpeed[i] = 0.0f;
      mRotPivotOffset[i].set( 0.0f, 0.0f );
      mRotPos[i] = 0.0f;

      mWavePos[i] = 0.0f;
      mWaveFreq[i] = 0.0f;
      mWaveAmp[i] = 0.0f;
      mWaveType[i] = 0;

      mSeqFramePerSec[i] = 0.0f;
      mSeqSegSize[i] = 0.0f;
   }

   mIsIFL = false;

   mDoubleSided = false;

   mTranslucent = false;
   mTranslucentBlendOp = LerpAlpha;
   mTranslucentZWrite = false;

   mAlphaTest = false;
   mAlphaRef = 1;

   mCastShadows = true;

   mPlanarReflection = false;

   mCubemapData = NULL;
   mDynamicCubemap = NULL;

   mLastUpdateTime = 0;

   mAutoGenerated = false;

   mShowDust = false;
   mShowFootprints = false;

   dMemset( mEffectColor,     0, sizeof( mEffectColor ) );

   mFootstepSoundId = -1;     mImpactSoundId = -1;
   mFootstepSoundCustom = 0;  mImpactSoundCustom = 0;
   mFriction = 0.0;
}

void Material::initPersistFields()
{
   addField("mapTo",                TypeRealString,      Offset(mMapTo, Material));

   addArray( "Stages", MAX_STAGES );

      addField("diffuseColor",      TypeColorF,          Offset(mDiffuse, Material), MAX_STAGES);
      addField("colorMultiply",     TypeColorF,          Offset(mColorMultiply, Material), MAX_STAGES);

      addField("diffuseMap",        TypeImageFilename,   Offset(mDiffuseMapFilename, Material), MAX_STAGES);
      addField("baseTex",           TypeImageFilename,   Offset(mBaseTexFilename, Material), MAX_STAGES); // For backwards compatibility

      addField("overlayMap",        TypeImageFilename,   Offset(mOverlayMapFilename, Material), MAX_STAGES);
      addField("overlayTex",        TypeImageFilename,   Offset(mOverlayTexFilename, Material), MAX_STAGES); // For backwards compatibility

      addField("lightMap",          TypeImageFilename,   Offset(mLightMapFilename, Material), MAX_STAGES);
      addField("toneMap",           TypeImageFilename,   Offset(mToneMapFilename, Material), MAX_STAGES);

      addField("detailMap",         TypeImageFilename,   Offset(mDetailMapFilename, Material), MAX_STAGES);
      addField("detailTex",         TypeImageFilename,   Offset(mDetailTexFilename, Material), MAX_STAGES); // For backwards compatibility

      addField("detailScale",       TypePoint2F,         Offset(mDetailScale,  Material), MAX_STAGES);

      addField( "normalMap",        TypeImageFilename,   Offset(mNormalMapFilename, Material), MAX_STAGES, NULL,
         "The normal map texture.  You can use the DXTnm format only when per-pixel "
         "specular highlights are disabled, or a specular map is in use." );
      addField( "bumpTex",          TypeImageFilename,   Offset(mBumpTexFilename, Material), MAX_STAGES, NULL, // For backwards compatibility
         "The normal map texture.  You can use the DXTnm format only when per-pixel "
         "specular highlights are disabled, or a specular map is in use." );

      addField("specular",          TypeColorF,          Offset(mSpecular, Material), MAX_STAGES);
      addField("specularPower",     TypeF32,             Offset(mSpecularPower, Material), MAX_STAGES);
      addField("pixelSpecular",     TypeBool,            Offset(mPixelSpecular, Material), MAX_STAGES, NULL, 
         "This enables per-pixel specular highlights controlled by the alpha channel of the "
         "normal map texture.  Note that if pixel specular is enabled the DXTnm format will not "
         "work with your normal map, unless you are also using a specular map." );
      addField( "specularMap",      TypeImageFilename,   Offset(mSpecularMapFilename, Material), MAX_STAGES, NULL,
         "The specular map texture. The RGB channels of this texture provide a per-pixel replacement for the 'specular' parameter on the material. "
         "If this texture contains alpha information, the alpha channel of the texture will be used as the gloss map. "
         "This provides a per-pixel replacement for the 'specularPower' on the material" );

      addField( "parallaxScale", TypeF32, Offset(mParallaxScale, Material), MAX_STAGES );
      
      addField("envMap",            TypeImageFilename,   Offset(mEnvMapFilename, Material), MAX_STAGES);
      addField("envTex",            TypeImageFilename,   Offset(mEnvTexFilename, Material), MAX_STAGES); // For backwards compatibility

      addField("vertLit",           TypeBool,            Offset(mVertLit, Material), MAX_STAGES);

      addField("minnaertConstant",  TypeF32,             Offset(mMinnaertConstant, Material),  MAX_STAGES);

      addField("subSurface",        TypeBool,            Offset(mSubSurface, Material),  MAX_STAGES);
      addField("subSurfaceColor",   TypeColorF,          Offset(mSubSurfaceColor, Material),  MAX_STAGES);
      addField("subSurfaceRolloff", TypeF32,             Offset(mSubSurfaceRolloff, Material),  MAX_STAGES);

      addField("exposure",          TypeS32,             Offset(mExposure, Material), MAX_STAGES);
      addField("glow",              TypeBool,            Offset(mGlow, Material), MAX_STAGES);
      addField("emissive",          TypeBool,            Offset(mEmissive, Material), MAX_STAGES);

      addField("doubleSided",       TypeBool,            Offset(mDoubleSided, Material));

      addField("animFlags",         TypeBitMask32,       Offset(mAnimFlags, Material), MAX_STAGES, &mAnimFlagTable );
      addField("scrollDir",         TypePoint2F,         Offset(mScrollDir, Material), MAX_STAGES);
      addField("scrollSpeed",       TypeF32,             Offset(mScrollSpeed, Material), MAX_STAGES);
      addField("rotSpeed",          TypeF32,             Offset(mRotSpeed, Material), MAX_STAGES);
      addField("rotPivotOffset",    TypePoint2F,         Offset(mRotPivotOffset, Material), MAX_STAGES);

      addField("waveType",          TypeEnum,            Offset(mWaveType,  Material), MAX_STAGES, &mWaveTypeTable );
      addField("waveFreq",          TypeF32,             Offset(mWaveFreq,  Material), MAX_STAGES);
      addField("waveAmp",           TypeF32,             Offset(mWaveAmp,   Material), MAX_STAGES);

      addField("sequenceFramePerSec", TypeF32,           Offset(mSeqFramePerSec,  Material), MAX_STAGES);
      addField("sequenceSegmentSize", TypeF32,           Offset(mSeqSegSize,  Material), MAX_STAGES);

   endArray( "Stages" );

   addField( "castShadows", TypeBool, Offset(mCastShadows, Material),
      "If set to false the lighting system will not cast shadows from this material." );

   addField("planarReflection",     TypeBool,            Offset(mPlanarReflection, Material));

   addField("translucent",          TypeBool,            Offset(mTranslucent, Material));
   addField("translucentBlendOp",   TypeEnum,            Offset(mTranslucentBlendOp, Material), 1, &mBlendOpTable);
   addField("translucentZWrite",    TypeBool,            Offset(mTranslucentZWrite, Material));
   addField("alphaTest",            TypeBool,            Offset(mAlphaTest, Material));
   addField("alphaRef",             TypeS32,             Offset(mAlphaRef, Material));

   addField("cubemap",              TypeRealString,      Offset(mCubemapName, Material));
   addField("dynamicCubemap",       TypeBool,            Offset(mDynamicCubemap, Material));

   addGroup( "Behavioral" );

      addField( "showFootprints",      TypeBool,            Offset( mShowFootprints, Material ) );
      addField( "showDust",            TypeBool,            Offset( mShowDust, Material ) );
      addField( "effectColor",         TypeColorF,          Offset( mEffectColor, Material ), NUM_EFFECT_COLOR_STAGES );
      addField( "footstepSoundId",     TypeS32,             Offset( mFootstepSoundId, Material ) );
      addField( "customFootstepSound", TypeSFXProfilePtr,   Offset( mFootstepSoundCustom, Material ) );
      addField( "impactSoundId",       TypeS32,             Offset( mImpactSoundId, Material ) );
      addField( "customImpactSound",   TypeSFXProfilePtr,   Offset( mImpactSoundCustom, Material ) );
      addField( "friction",            TypeF32,             Offset( mFriction, Material ) );

   endGroup( "Behavioral" );

   Parent::initPersistFields();
}

bool Material::onAdd()
{
   if (Parent::onAdd() == false)
      return false;

   mCubemapData = dynamic_cast<CubemapData*>(Sim::findObject( mCubemapName ) );

   if( mTranslucentBlendOp >= NumBlendTypes || mTranslucentBlendOp < 0 )
   {
      Con::errorf( "Invalid blend op in material: %s", getName() );
      mTranslucentBlendOp = LerpAlpha;
   }

   SimSet *matSet = MATMGR->getMaterialSet();
   if( matSet )
      matSet->addObject( (SimObject*)this );

   // save the current script path for texture lookup later
   const String  scriptFile = Con::getVariable("$Con::File");  // current script file - local materials.cs

   String::SizeType  slash = scriptFile.find( '/', scriptFile.length(), String::Right );

   AssertFatal( slash != String::NPos, "Invalid value for $Con::File - missing '/'" );

   mPath = scriptFile.substr( 0, slash + 1 );

   _mapMaterial();

   return true;
}

void Material::onRemove()
{
   smNormalizeCube = NULL;
   Parent::onRemove();
}

void Material::inspectPostApply()
{
   Parent::inspectPostApply();

   // Reload the material instances which 
   // use this material.
   if ( isProperlyAdded() )
      reload();
}


bool Material::isLightmapped() const
{
   bool ret = false;
   for( U32 i=0; i<MAX_STAGES; i++ )
      ret |= mLightMapFilename[i].isNotEmpty() || mToneMapFilename[i].isNotEmpty() || mVertLit[i];
   return ret;
}

void Material::updateTimeBasedParams()
{
   U32 lastTime = MATMGR->getLastUpdateTime();
   F32 dt = MATMGR->getDeltaTime();
   if (mLastUpdateTime != lastTime)
   {
      for (U32 i = 0; i < MAX_STAGES; i++)
      {
         mScrollOffset[i] += mScrollDir[i] * mScrollSpeed[i] * dt;
         mRotPos[i] += mRotSpeed[i] * dt;
         mWavePos[i] += mWaveFreq[i] * dt;
      }
      mLastUpdateTime = lastTime;
   }
}

void Material::_mapMaterial()
{
   if( String(getName()).isEmpty() )
   {
      Con::warnf( "[Material::mapMaterial] - Cannot map unnamed Material" );
      return;
   }

   // If mapTo not defined in script, try to use the base texture name instead
   if( mMapTo.isEmpty() )
   {
      mIsIFL = false;

      if( mDiffuseMapFilename[0].isEmpty() && mBaseTexFilename[0].isEmpty() )
      {
         return;
      }
      else
      {
         // extract filename from base texture
         if ( mDiffuseMapFilename[0].isNotEmpty() )
         {
            U32 slashPos = mDiffuseMapFilename[0].find('/',0,String::Right);
            if (slashPos == String::NPos)
               // no '/' character, must be no path, just the filename
               mMapTo = mDiffuseMapFilename[0];
            else
               // use everything after the last slash
               mMapTo = mDiffuseMapFilename[0].substr(slashPos+1, mDiffuseMapFilename[0].length() - slashPos - 1);
         }
         else if ( mBaseTexFilename[0].isNotEmpty() )
         {
            U32 slashPos = mBaseTexFilename[0].find('/',0,String::Right);
            if (slashPos == String::NPos)
               // no '/' character, must be no path, just the filename
               mMapTo = mBaseTexFilename[0];
            else
               // use everything after the last slash
               mMapTo = mBaseTexFilename[0].substr(slashPos+1, mBaseTexFilename[0].length() - slashPos - 1);
         }
      }
   }
   else
   {
      mIsIFL = String::NPos != mMapTo.find(".ifl", String::NoCase);
   }

   // add mapping
   MATMGR->mapMaterial(mMapTo,getName());
}

BaseMatInstance* Material::createMatInstance()
{
   return new MatInstance(*this);
}

void Material::flush()
{
   MATMGR->flushInstance( this );
}

void Material::reload()
{
   MATMGR->reInitInstance( this );
}

ConsoleMethod( Material, flush, void, 2, 2, 
   "Flushes all material instances that use this material." )
{
   object->flush();
}

ConsoleMethod( Material, reload, void, 2, 2, 
   "Reloads all material instances that use this material." )
{
   object->reload();
}

ConsoleMethod( Material, dumpInstances, void, 2, 2, 
   "Dumps a formatted list of the currently allocated material instances for this material to the console." )
{
   MATMGR->dumpMaterialInstances( object );
}

ConsoleMethod( Material, getAnimFlags, const char*, 3, 3, "" )
{
   char * animFlags = Con::getReturnBuffer(512);

   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Scroll)
   {
	   if(dStrcmp( animFlags, "" ) == 0)
	      dStrcpy( animFlags, "$Scroll" );
   }
   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Rotate)
   {
	   if(dStrcmp( animFlags, "" ) == 0)
	      dStrcpy( animFlags, "$Rotate" );
	   else
			dStrcat( animFlags, " | $Rotate");
   }
   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Wave)
   {
	   if(dStrcmp( animFlags, "" ) == 0)
	      dStrcpy( animFlags, "$Wave" );
	   else
			dStrcat( animFlags, " | $Wave");
   }
   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Scale)
   {
	   if(dStrcmp( animFlags, "" ) == 0)
	      dStrcpy( animFlags, "$Scale" );
	   else
			dStrcat( animFlags, " | $Scale");
   }
   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Sequence)
   {
	   if(dStrcmp( animFlags, "" ) == 0)
	      dStrcpy( animFlags, "$Sequence" );
	   else
			dStrcat( animFlags, " | $Sequence");
   }

	return animFlags;
}

ConsoleMethod(Material, getFilename, const char*, 2, 2, "Get filename of material")
{
	SimObject *material = static_cast<SimObject *>(object);
   return material->getFilename();
}

ConsoleMethod( Material, isAutoGenerated, bool, 2, 2, 
              "Returns true if this Material was automatically generated by MaterialList::mapMaterials()" )
{
   return object->isAutoGenerated();
}

ConsoleMethod( Material, setAutoGenerated, void, 3, 3, 
              "setAutoGenerated(bool isAutoGenerated): Set whether or not the Material is autogenerated." )
{
   object->setAutoGenerated(dAtob(argv[2]));
}